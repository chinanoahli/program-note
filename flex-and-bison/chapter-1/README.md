# chapter 1

## flex词法分析器

### flex程序语法

**例1-1**：字数统计 *fb1-1.l*
```flex
%{

// 被`%{`和`%}`包围的的部分会被flex原封不动地复制到C程序中
// `%{`和`%}`前方不可以有任何字符，包括空格，flex对此敏感
// flex程序的第一部分为声明和选项设置（声明部分）

int chars = 0;    
int words = 0;
int lines = 0;
%}

%%

// 仅有`%%`的行会被用作分割flex程序
// 同样地，`%%`前方和后方不可以有任何字符，包括空格

// 以下flex程序的第二部分为一系列的匹配模式和动作（规则部分）

[a-zA-Z]+  {words++; chars += strlen(yytext);}
\n         {chars++; lines++;}
.          {chars++;}
%%

// flex程序的第三部分会被拷贝到生成的语法分析器里边的C代码（C代码部分）
// 原书代码片段没有使用`int main`这种标准的声明方式
// 如果直接采用原书的书写方式，会被编译器警告

int main(int argc, char **argv)
{
  yylex();
  printf("%8d%8d%8d", lines, words, chars);
  return 0;
}
```

在flex程序中，如果匹配模式不需要执行任何动作，则可以这样写：

```flex
[ \t]  { }    // 匹配任意空格或tab，但匹配后不做任何动作
```

而匹配字符的字面值可以这样写：

```flex
"+"  { }    // 匹配+号本身，而不是将+理解成匹配模式
```

flex程序的第三部分可以被省略。

### 手动编译和运行flex程序的办法

```shell
$ flex fb1-1.l        # flex会生成名为`lex.yy.c`的C代码文件
$ cc lex.yy.c -lfl    # 用C编译器cc编译flex生成的C代码，生成可执行文件`a.out`
$ ./a.out             # 运行生成的程序
the boy stood on the burning deck
shelling peanuts by the peck
^D
       2      12      63
$
```

编译出来的程序默认从标准输入直接读取输入。

### flex的工作方式

flex程序返回的是一个记号（token）流。

当程序需要读取记号时，可以调用`yylex()`来读取一些输入，然后flex就会从输入中返回相应的记号。

当程序再次需要记号时，`yylex()`会被再次调用。

一般来说，语法分析器会与程序协同工作。

flex在返回记号的同时，它也会记住当前处理的位置，程序再次调用`yylex()`时，就可以从记住的位置开始，去处理下次的调用。

在flex进行词法分析时，如果识别到一个token，`yyelex()`就会将这个token作为返回值返回。

当在个输入片段中，发现了不符合任何匹配模式（不能调用别的程序，也不能作为token被返回）的无效输入时，`yyelx()`就会跳过这段输入，立即继续读取后面的输入。

在flex进行词法分析时，它所返回的记号流，实际上是由两个部分组成，分别是*记号编号（token number）*和*记号值（token's value）*。

记号编号代表的是token的类型，而记号值才是token的值，所以记号编号时允许重复的，而记号值则根据匹配到的内容而变化。

`yylex()`会返回记号编号，`yytext()`会返回记号值。

记号编号是随机确定的，文件结束由专有的记号编号——零值。

## bison 语法分析器

bison可以视为一种语法被简化的BNF。

bison在创建语法分析器时，会自动从`258`开始指派记号编号，当然用户也可以手动指派编号。

bison程序包含了与flex程序相同的三部分结构：声明部分、规则部分和C代码部分。

同样地声明部分中，被`%{ }%`说包括的内容会被原样拷贝到最终的C程序的开头。

随后是以`%token`开头的记号声明，记号声明可以告诉bison在语法分析程序中，需要用到的记号的名称。

（通常来说为了方便程序阅读记号名称一般以全大写号码书写，但这不是强制的）

任何没有声明为记号的**语法符号**必须出现在至少一条规则的**左边**。

在规则部分中，包含了通过简单的类BNF语法定义的规则，所以动作代码只需要维护每个语法符号关联的语义值。

（bison也会执行一些额外的动作，如创建数据结构，以便后续使用等之类的动作）

第一条规则左边的语法符号被称为语法*起始符号（start symobl）*，整个输入必须被它匹配。

其他规则的左边也可以拥有相同的起始符号。

每一个bison规则中的语法符号都有一个语义值，目标符号（冒号左边的语法符号）的语义值在动作中用`$$`代替，右边的语法符号的语义值依次以`$1`、`$2`代替，依次类推，直到规则的结束。

**例1-5**：简单的计算器 *fb1-5.y* （片段）

```bison
// 假设以下规则是第一条规则

  exp: factor                             // 因为这是第一条规则，所以exp为起始符号
    | exp ADD factor { $$ = $1 + $3; }    // `$$`代表exp本身，因为exp在`:`左侧是目标符号
    | exp SUB factor { $$ = $1 - $3; }    // `$1`和`$3`分别代表第1和第3个语法符号的语义值
  ;                                       // 规则结束
```

## 联合编译flex和bison程序

我们的最终目标是要让词法分析器flex辅助bison进行语法分析，所以我们需要将flex和bison代码都编译到同一个程序里。

为此我们需要将词法分析器的*fb1-5.l*修改成下面的样子，让flex自动生成记号编号等我们需要用到的东西。

```flex
%{
#include "fb1-5.tab.h"
%}

%%
// 与之前的规则相同，同样不需要第三部分的C代码，因为C代码已经在fb1-5.y中实现，如：

"+"     { return ADD; }
"-"     { return SUB; }
"*"     { return MUL; }
// 等等，省略部分代码

%%
```

### 编译步骤

手动编译：

```shell
$ flex fb1-5.l
$ bison -d fb1-5.y
$ cc -o fb1-5 fb1-5.tab.c lex.yy.c -lfl
```

或使用Makefile编译：

```Makefile
fb1-5: fb1-5.l fb1-5.y
	bison -d fb1-5.y
	flex fb1-5.l
	cc -o $@ fb1-5.tab.c lex.yy.c -lfl
```

## 练习

1. 不接受。因为在示例程序中，只有注释的行并未包含在bison词法分析器列举的任一状况之中，在词法分析器中作出修改会更加简单，因为只需要在起始符号中修改即可。

2. 之后的习题有空再研究。
